"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CucumberExpressionError_js_1 = __importDefault(require("./CucumberExpressionError.js"));
const CucumberExpressionGenerator_js_1 = __importDefault(require("./CucumberExpressionGenerator.js"));
const defineDefaultParameterTypes_js_1 = __importDefault(require("./defineDefaultParameterTypes.js"));
const Errors_js_1 = require("./Errors.js");
const ParameterType_js_1 = __importDefault(require("./ParameterType.js"));
class ParameterTypeRegistry {
    parameterTypeByName = new Map();
    parameterTypesByRegexp = new Map();
    constructor() {
        (0, defineDefaultParameterTypes_js_1.default)(this);
    }
    get parameterTypes() {
        return this.parameterTypeByName.values();
    }
    lookupByTypeName(typeName) {
        return this.parameterTypeByName.get(typeName);
    }
    lookupByRegexp(parameterTypeRegexp, expressionRegexp, text) {
        const parameterTypes = this.parameterTypesByRegexp.get(parameterTypeRegexp);
        if (!parameterTypes) {
            return undefined;
        }
        if (parameterTypes.length > 1 && !parameterTypes[0].preferForRegexpMatch) {
            // We don't do this check on insertion because we only want to restrict
            // ambiguity when we look up by Regexp. Users of CucumberExpression should
            // not be restricted.
            const generatedExpressions = new CucumberExpressionGenerator_js_1.default(() => this.parameterTypes).generateExpressions(text);
            throw Errors_js_1.AmbiguousParameterTypeError.forRegExp(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);
        }
        return parameterTypes[0];
    }
    defineParameterType(parameterType) {
        if (parameterType.name !== undefined) {
            if (this.parameterTypeByName.has(parameterType.name)) {
                if (parameterType.name.length === 0) {
                    throw new CucumberExpressionError_js_1.default(`The anonymous parameter type has already been defined`);
                }
                else {
                    throw new CucumberExpressionError_js_1.default(`There is already a parameter type with name ${parameterType.name}`);
                }
            }
            this.parameterTypeByName.set(parameterType.name, parameterType);
        }
        for (const parameterTypeRegexp of parameterType.regexpStrings) {
            if (!this.parameterTypesByRegexp.has(parameterTypeRegexp)) {
                this.parameterTypesByRegexp.set(parameterTypeRegexp, []);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const parameterTypes = this.parameterTypesByRegexp.get(parameterTypeRegexp);
            const existingParameterType = parameterTypes[0];
            if (parameterTypes.length > 0 &&
                existingParameterType.preferForRegexpMatch &&
                parameterType.preferForRegexpMatch) {
                throw new CucumberExpressionError_js_1.default('There can only be one preferential parameter type per regexp. ' +
                    `The regexp /${parameterTypeRegexp}/ is used for two preferential parameter types, {${existingParameterType.name}} and {${parameterType.name}}`);
            }
            if (parameterTypes.indexOf(parameterType) === -1) {
                parameterTypes.push(parameterType);
                this.parameterTypesByRegexp.set(parameterTypeRegexp, parameterTypes.sort(ParameterType_js_1.default.compare));
            }
        }
    }
}
exports.default = ParameterTypeRegistry;
//# sourceMappingURL=ParameterTypeRegistry.js.map