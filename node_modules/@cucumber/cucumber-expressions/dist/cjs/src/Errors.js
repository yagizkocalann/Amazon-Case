"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UndefinedParameterTypeError = exports.AmbiguousParameterTypeError = void 0;
exports.createAlternativeMayNotExclusivelyContainOptionals = createAlternativeMayNotExclusivelyContainOptionals;
exports.createAlternativeMayNotBeEmpty = createAlternativeMayNotBeEmpty;
exports.createOptionalMayNotBeEmpty = createOptionalMayNotBeEmpty;
exports.createParameterIsNotAllowedInOptional = createParameterIsNotAllowedInOptional;
exports.createOptionalIsNotAllowedInOptional = createOptionalIsNotAllowedInOptional;
exports.createTheEndOfLIneCanNotBeEscaped = createTheEndOfLIneCanNotBeEscaped;
exports.createMissingEndToken = createMissingEndToken;
exports.createAlternationNotAllowedInOptional = createAlternationNotAllowedInOptional;
exports.createCantEscaped = createCantEscaped;
exports.createInvalidParameterTypeNameInNode = createInvalidParameterTypeNameInNode;
exports.createUndefinedParameterType = createUndefinedParameterType;
const Ast_js_1 = require("./Ast.js");
const CucumberExpressionError_js_1 = __importDefault(require("./CucumberExpressionError.js"));
function createAlternativeMayNotExclusivelyContainOptionals(node, expression) {
    return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), 'An alternative may not exclusively contain optionals', "If you did not mean to use an optional you can use '\\(' to escape the '('"));
}
function createAlternativeMayNotBeEmpty(node, expression) {
    return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), 'Alternative may not be empty', "If you did not mean to use an alternative you can use '\\/' to escape the '/'"));
}
function createOptionalMayNotBeEmpty(node, expression) {
    return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), 'An optional must contain some text', "If you did not mean to use an optional you can use '\\(' to escape the '('"));
}
function createParameterIsNotAllowedInOptional(node, expression) {
    return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), 'An optional may not contain a parameter type', "If you did not mean to use an parameter type you can use '\\{' to escape the '{'"));
}
function createOptionalIsNotAllowedInOptional(node, expression) {
    return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), 'An optional may not contain an other optional', "If you did not mean to use an optional type you can use '\\(' to escape the '('. For more complicated expressions consider using a regular expression instead."));
}
function createTheEndOfLIneCanNotBeEscaped(expression) {
    const index = Array.from(expression).length - 1;
    return new CucumberExpressionError_js_1.default(message(index, expression, pointAt(index), 'The end of line can not be escaped', "You can use '\\\\' to escape the '\\'"));
}
function createMissingEndToken(expression, beginToken, endToken, current) {
    const beginSymbol = (0, Ast_js_1.symbolOf)(beginToken);
    const endSymbol = (0, Ast_js_1.symbolOf)(endToken);
    const purpose = (0, Ast_js_1.purposeOf)(beginToken);
    return new CucumberExpressionError_js_1.default(message(current.start, expression, pointAtLocated(current), `The '${beginSymbol}' does not have a matching '${endSymbol}'`, `If you did not intend to use ${purpose} you can use '\\${beginSymbol}' to escape the ${purpose}`));
}
function createAlternationNotAllowedInOptional(expression, current) {
    return new CucumberExpressionError_js_1.default(message(current.start, expression, pointAtLocated(current), 'An alternation can not be used inside an optional', "If you did not mean to use an alternation you can use '\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead."));
}
function createCantEscaped(expression, index) {
    return new CucumberExpressionError_js_1.default(message(index, expression, pointAt(index), "Only the characters '{', '}', '(', ')', '\\', '/' and whitespace can be escaped", "If you did mean to use an '\\' you can use '\\\\' to escape it"));
}
function createInvalidParameterTypeNameInNode(token, expression) {
    return new CucumberExpressionError_js_1.default(message(token.start, expression, pointAtLocated(token), "Parameter names may not contain '{', '}', '(', ')', '\\' or '/'", 'Did you mean to use a regular expression?'));
}
function message(index, expression, pointer, problem, solution) {
    return `This Cucumber Expression has a problem at column ${index + 1}:

${expression}
${pointer}
${problem}.
${solution}`;
}
function pointAt(index) {
    const pointer = [];
    for (let i = 0; i < index; i++) {
        pointer.push(' ');
    }
    pointer.push('^');
    return pointer.join('');
}
function pointAtLocated(node) {
    const pointer = [pointAt(node.start)];
    if (node.start + 1 < node.end) {
        for (let i = node.start + 1; i < node.end - 1; i++) {
            pointer.push('-');
        }
        pointer.push('^');
    }
    return pointer.join('');
}
class AmbiguousParameterTypeError extends CucumberExpressionError_js_1.default {
    static forRegExp(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions) {
        return new this(`Your Regular Expression ${expressionRegexp}
matches multiple parameter types with regexp ${parameterTypeRegexp}:
   ${this._parameterTypeNames(parameterTypes)}

I couldn't decide which one to use. You have two options:

1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:
   ${this._expressions(generatedExpressions)}

2) Make one of the parameter types preferential and continue to use a Regular Expression.
`);
    }
    static _parameterTypeNames(parameterTypes) {
        return parameterTypes.map((p) => `{${p.name}}`).join('\n   ');
    }
    static _expressions(generatedExpressions) {
        return generatedExpressions.map((e) => e.source).join('\n   ');
    }
}
exports.AmbiguousParameterTypeError = AmbiguousParameterTypeError;
class UndefinedParameterTypeError extends CucumberExpressionError_js_1.default {
    undefinedParameterTypeName;
    constructor(undefinedParameterTypeName, message) {
        super(message);
        this.undefinedParameterTypeName = undefinedParameterTypeName;
    }
}
exports.UndefinedParameterTypeError = UndefinedParameterTypeError;
function createUndefinedParameterType(node, expression, undefinedParameterTypeName) {
    return new UndefinedParameterTypeError(undefinedParameterTypeName, message(node.start, expression, pointAtLocated(node), `Undefined parameter type '${undefinedParameterTypeName}'`, `Please register a ParameterType for '${undefinedParameterTypeName}'`));
}
//# sourceMappingURL=Errors.js.map